--- links-2.12.unmodified/sdl.c
+++ links-2.12/sdl.c
@@ -0,0 +1,1037 @@
+/*sdl.c
+	-- SDL graphic driver for Links (version 0.1.2)
+
+    Copyright (C) 2004	Samuel Behan <sam(at)frida(dot)fri(dot)utc(dot)sk>
+
+    This driver is free software; you can redistribute it and/or
+    modify it under the terms of the GNU General Public License
+    as published by the Free Software Foundation; either version 2
+    of the License, or (at your option) any later version.
+
+    This driver is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    ---
+    I've wrote this driver just as a proof of concept for using SDL library. I wanted
+    to use something easy, so i've decided for the world's best web browser :)
+
+    TODO & BUGS:
+	- keyboard input system doesn't handles all characters, because sdl ignores any
+		system mappings and provides something like `raw keyboard access'
+	- *_strip functions are possibly bad implemented, actualy i don't understand what
+		they should do, or better i'm too lazy to find it out :)
+	- video initialization is static only, nor parametrized !!!
+	- BUGBUG: aa-lib nor caca lib, dont display nicely - they actualy display nothing ;(
+			This needs to be fixed, becase links over aa-lib as that what i've been
+			dreaming of [ try set env SDL_VIDEODRIVER="aalib" ]
+	* resize does not works (fixed)
+	? sdl_set_title should possibly convert passed strings
+	...and many more, not found yet :)
+*/
+
+
+#include "cfg.h"
+
+#ifdef GRDRV_SDL
+
+#ifdef TEXT
+#undef TEXT
+#endif
+
+#include "links.h"
+#include <signal.h>
+/* #include "arrow.inc" */
+
+/*sdl inclusions*/
+#include <SDL.h>
+#include <SDL_gfxPrimitives.h>
+
+
+/* helper tools */
+/* FIXME: enabled debug mode */
+#undef DEBUG
+#ifdef DEBUG
+#include <assert.h>
+#define S_ASSERT(code)	assert((code))
+#define S_ON_DEBUG(code)	code
+#define S_ON_DEBUG_TRACE(str)	fprintf(stderr, "[%s:%s:%d] %s\n", __FILE__, __PRETTY_FUNCTION__, __LINE__, str);
+#else
+#define S_ASSERT(code)
+#define S_ON_DEBUG(code)
+#define S_ON_DEBUG_TRACE(str)
+#endif
+
+/* internal types */
+typedef unsigned char 		u_char_t;
+typedef unsigned short int	u_short_t;
+struct graphics_driver sdl_driver;
+int display_inactive = 0;
+
+/* keysyms */
+#include "sdl_data.inc"
+
+static struct t_sdl_driver_data {
+	u_char_t	*video_drv;		/* used video driver name */
+	SDL_VideoInfo	*video_info;		/* video informations */
+	SDL_Cursor	*cursor;		/* cursor */
+	int		event_timer;		/* event timer id */
+	struct {
+		long  int	flags;		/* video flags */
+		short int	width;
+		short int	height;
+		short int	depth;
+	} video;
+} sdl_data = {
+	NULL,
+	NULL,
+	NULL,
+	0,
+	{ 0, 0, 0, 0 },
+};
+#define sdl_VIDEO_WIDTH		sdl_DATA.video.width
+#define sdl_VIDEO_HEIGHT	sdl_DATA.video.height
+#define sdl_VIDEO_DEPTH		sdl_DATA.video.depth
+#define sdl_VIDEO_FLAGS		sdl_DATA.video.flags
+
+/* DRIVER DATA HELPERS */ 
+#define sdl_DATA		sdl_data
+#define sdl_DATA_FREE()		if(sdl_DATA.video_drv != NULL)	mem_free(sdl_DATA.video_drv);	\
+				if(sdl_DATA.video_info != NULL)	mem_free(sdl_DATA.video_info);
+struct t_sdl_device_data {
+	SDL_Surface 		*p_surf;		/* primary surface	*/
+	struct graphics_device	*g_dev;			/* draphic device	*/
+/*	SDL_Rect		u_rect;	*/		/* update rectangle	*/
+	short			u_pending;		/* update pending	*/
+};
+#define sdl_SURFACE(ptr)	(ptr)->p_surf
+#define sdl_GD(ptr)		(ptr)->g_dev
+#define sdl_URECT(ptr)		(ptr)->u_rect
+#define sdl_UPENDING(ptr)	(ptr)->u_pending
+
+/* HELPER FUNCTIONS */
+#define sdl_COLOR(col)			(((col) << 2) | 0x00)
+
+#define sdl_SETUP_TIMER(dev)		\
+		sdl_DATA.event_timer	= install_timer(20, sdl_catch_event, (dev))
+#define sdl_KILL_TIMER()		\
+		kill_timer(sdl_DATA.event_timer)
+
+/* event catch helpers */
+#define sdl_CATCH_EVENTS_NUM	3
+#define sdl_MOUSE_STATE(var_in, var_out, def)	\
+		if(var_in == SDL_BUTTON(SDL_BUTTON_LEFT))			\
+			var_out	|= B_LEFT;					\
+		else if(var_in == SDL_BUTTON(SDL_BUTTON_RIGHT))			\
+			var_out	|= B_RIGHT;					\
+		else if(var_in == SDL_BUTTON(SDL_BUTTON_MIDDLE))		\
+			var_out	|= B_MIDDLE;					\
+		else if(var_in == SDL_BUTTON(SDL_BUTTON_WHEELUP))		\
+			var_out	|= B_WHEELUP;					\
+		else if(var_in == SDL_BUTTON(SDL_BUTTON_WHEELDOWN))		\
+			var_out	|= B_WHEELDOWN;					\
+		else	var_out	= (def);
+
+
+
+/* tha event handler */
+static void sdl_catch_event(void *data)
+{
+    register int i = 0, ev_num	= 0;
+    register struct t_sdl_device_data *dev	= NULL;
+    SDL_Event events[sdl_CATCH_EVENTS_NUM];
+    u_short_t	fl	= 0;
+    /* speedup (BUGGY, not thread safe !?!) */
+    static u_short_t o_x = 0, o_y = 0, o_fl = 0;
+#ifdef ZIPIT_Z2
+    static int dead_key = 0;
+
+ //   static FILE *fp = NULL;      
+#endif
+
+    SDL_PumpEvents();
+    ev_num	= SDL_PeepEvents(events, sdl_CATCH_EVENTS_NUM, SDL_GETEVENT, SDL_ALLEVENTS);
+/*
+    S_ON_DEBUG(fprintf(stderr, "event: received %d\n", ev_num); );
+*/  
+    S_ASSERT(ev_num != -1);
+    /* get dev data */
+    dev		= (struct t_sdl_device_data *) data;
+    for(i = 0; i < ev_num; i++)
+    {
+#define event events[i]
+	switch (event.type)
+	{
+			case SDL_ACTIVEEVENT: {
+				
+				if (SDL_GetAppState() & SDL_APPACTIVE){
+					display_inactive = 0;
+					SDL_UpdateRect(sdl_SURFACE(dev), 0, 0, 0, 0);
+					sdl_GD(dev)->resize_handler(sdl_GD(dev));					
+				}
+				else
+					display_inactive = 1;
+				
+				break;
+			}
+		
+/*	    case SDL_ACTIVEEVENT:	*/
+	    /* mouse motion */
+            case SDL_MOUSEMOTION:
+		/* mose btn state */
+	        S_ON_DEBUG_TRACE("event: mouse motion");
+		fl	= B_DRAG;
+		sdl_MOUSE_STATE(event.motion.state, fl, B_MOVE);
+		/* save som calls (SDL generates many similar events)	*/
+		if(event.motion.x == o_x && event.motion.y == o_y && fl == o_fl)
+			break;
+		/* call handler */
+		sdl_GD(dev)->mouse_handler(sdl_GD(dev), event.motion.x, event.motion.y, fl);
+		o_x	= event.motion.x;
+		o_y	= event.motion.y;
+		o_fl	= fl;
+                break;
+	    /* mouse click */
+	    case SDL_MOUSEBUTTONUP:
+            case SDL_MOUSEBUTTONDOWN:
+		if(event.type == SDL_MOUSEBUTTONDOWN)
+			fl	= B_DOWN;
+		else
+			fl	= B_UP;
+	        S_ON_DEBUG_TRACE("event: mouse click");
+/*		sdl_MOUSE_STATE(event.button.state, fl, fl);	*/
+		sdl_GD(dev)->mouse_handler(sdl_GD(dev), event.button.x, event.button.y, fl);
+		break;
+	    /* keyboard */
+	    case SDL_KEYUP:
+	        S_ON_DEBUG_TRACE("event: key up");
+			break;
+            case SDL_KEYDOWN:
+	       {	/*translate */
+			int		k	= 0;
+			int		key	= 0;
+/*
+*			//////////////////////////
+*			//FIXME: needs rework !!!
+*			//	-- sdl works at low-level ignoring any system keymappings
+*			//	i've no idea how to do it (easily):(
+*			//////////////////////////
+*/
+			S_ON_DEBUG_TRACE("event: key down");
+			while(sdl_keysyms[k].sym != event.key.keysym.sym && sdl_keysyms[k].sym != SDLK_LAST)
+				k++;
+			S_ASSERT(sdl_keysyms[k].sym != SDLK_LAST);
+			/* FIXME: hope nobody changes enumeration values in SDL libs */
+			if(sdl_keysyms[k].sym >= SDLK_NUMLOCK && sdl_keysyms[k].sym <= SDLK_COMPOSE) 
+				break;	/* aka ignore modifiers */
+#ifdef ZIPIT_Z2
+		//	if (fp == NULL)
+		//	  fp = fopen("/tmp/keylog.txt", "w");
+
+			/* key re-map */
+			key	= sdl_keysyms[k].key;
+			fl	= event.key.keysym.mod;
+			if((fl & KMOD_RALT) || (fl & KMOD_LALT)) /* (fl & KMOD_ALT) */
+			{
+			  if(fl & KMOD_SHIFT)
+			    key	= sdl_keysyms[k].sakey;
+			  else
+			    key	= sdl_keysyms[k].akey;
+			}
+			else if(fl & KMOD_SHIFT)
+			{
+			  if((fl & KMOD_RALT) || (fl & KMOD_LALT)) /* (fl & KMOD_ALT) */
+			    key	= sdl_keysyms[k].sakey;
+			  else
+			    key	= sdl_keysyms[k].skey;
+			}
+#if 1	
+			//fprintf(fp, "sym=%d, key=%d, u=%d, mod=0x%0X\n",
+			//	(int)sdl_keysyms[k].key, key, event.key.keysym.unicode, (int)fl);
+			/* Try the Unicode if available? (bad for sticky and KBD_* keys) */
+			if (((key >= 'a') && (key <= 'z')) || ((key >= 'A') && (key <= 'Z')) || (key == ' '))
+			{
+			  //if (!(fl & KMOD_CTRL) && (event.key.keysym.unicode == 0)) // Dead key
+			  if (event.key.keysym.unicode == 0) // Dead key
+			  {
+			    switch (key) {
+			    case 'A':
+			    case 'G':
+			    case 'D':
+			    case 'F':
+			    case 'T':
+			    case 'C':
+			      dead_key = key;
+			    default:
+			      break;
+			    case 'V':
+			      dead_key = 'C'; // (doppleganger for c)
+			      break;
+			    }
+			    //if (dead_key) fprintf(fp, "  dead=%c\n", dead_key);
+			    //else fprintf(fp, "  undead=0\n");
+			    break;	/* skip COMPOSE (dead) keys */
+			  }
+			  else if (dead_key)
+			  {
+			    if((key == 'V') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+			    {
+			      //fprintf(fp, "  decomposing %c+<%c>", dead_key, key);
+			      break; // (doppleganger for c)
+			    }
+			    //fprintf(fp, "  composing %c+<%c>", dead_key, key);
+			    if (key == ' ')
+			      key = 'Z'+1;
+			    if (dead_key == 'G') // (event.key.keysym.unicode == 0x300) // grave 
+			      key = grave_map[key - 'A'];
+			    else if (dead_key == 'A') // (event.key.keysym.unicode == 0x301) // acute 
+			      key = acute_map[key - 'A'];
+			    else if (dead_key == 'C') // (event.key.keysym.unicode == 0x302) // circum 
+			      key = circumflex_map[key - 'A'];
+			    else if (dead_key == 'T') // (event.key.keysym.unicode == 0x303) // tilde 
+			      key = tilde_map[key - 'A'];
+			    else if (dead_key == 'D') // (event.key.keysym.unicode == 0x308) // dia 
+			      key = diaeresis_map[key - 'A'];
+			    else if (dead_key == 'F') // (event.key.keysym.unicode == 0x327) // cedilla 
+			      key = cedilla_map[key - 'A'];
+			    dead_key = 0;
+			    //fprintf(fp, " = +<%c>\n", key);
+			  }
+#if 0
+			  else if((key == 'O') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+    			    break; // (doppleganger for p)
+			  else if((key == 'M') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+    			    key = 0xBF; // Upside down question (instead of percent)
+			  else if((key == 'R') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+    			    key = 0xB0; // Happier place for degree
+#else
+			  else if((key == 'P') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+    			    break; // (doppleganger for o)
+			  else if((key == 'Q') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+    			    key = 0xBF; // Happier place for upside down question
+#endif
+			  else if((key == 'W') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+    			    break; // (doppleganger for e)
+#if 0
+			  else if((key == 'N') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+			  {
+			    dead_key = 'C';  // Happier place for circumflex
+			    //fprintf(fp, "  fakedead=%c\n", dead_key);
+			    break;
+			  }
+#endif
+			  else if((key == 'V') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+			  {
+			    dead_key = 'C';  // Happier place for circumflex
+			    //fprintf(fp, "  fakeDEAD=%c\n", dead_key);
+			    break;
+			  }
+			  else
+			  {
+			  dead_key = 0;
+			  if (fl & KMOD_CTRL)
+			  {
+			    /* Skip unicode translation for ctrl keys. */
+			  } 
+			  else
+			  if (((event.key.keysym.unicode & 0xff80) == 0)) // ASCII
+			    key = event.key.keysym.unicode;
+			  else if ((event.key.keysym.unicode != 0) &&
+				   ((event.key.keysym.unicode & 0xff00) == 0)) // Latin 1 (8bit)
+			    key = event.key.keysym.unicode;
+			  else if (event.key.keysym.unicode == 0x20AC) // euro
+			    key = 0xA4; // Latin15
+			  //fprintf(fp, "  unicoding to <%c>\n", key);
+
+			  }
+			}
+			else
+			  dead_key = 0;
+#endif
+			//printf(fp, "  sym=%d, key=%d, u=%d, mod=0x%0X\n", (int)sdl_keysyms[k].key, key, event.key.keysym.unicode, (int)fl);
+			/* find modifiers */
+			fl	= 0;
+			if(event.key.keysym.mod & KMOD_SHIFT)
+				fl	|=	KBD_SHIFT;
+			if(event.key.keysym.mod & KMOD_ALT)
+				fl	|=	KBD_ALT;
+			if(event.key.keysym.mod & KMOD_CTRL)
+				fl	|=	KBD_CTRL;
+			/* If ALT changes the key on the Zipit then hide the SHIFT and ALT modifiers. */
+			if((event.key.keysym.mod & KMOD_ALT) && (key != sdl_keysyms[k].key))
+			  fl	&=	~(KBD_ALT|KBD_SHIFT);
+#else  /* not ZIPIT_Z2 */
+			/* find modifiers */
+			fl	= 0;
+			if(event.key.keysym.mod & KMOD_SHIFT)
+				fl	|=	KBD_SHIFT;
+			if(event.key.keysym.mod & KMOD_ALT)
+				fl	|=	KBD_ALT;
+			if(event.key.keysym.mod & KMOD_CTRL)
+				fl	|=	KBD_CTRL;
+			/* key re-map */
+			key	= sdl_keysyms[k].key;
+			/* upper letters fix (not handled directly by SDL) */
+			if(key >= 97 && key <= 122 && fl & KBD_SHIFT)
+			{	key	-= 32;
+				fl	&= ~KBD_SHIFT;	}
+			/* find modifiers */
+			fl	= 0;
+			if(event.key.keysym.mod & KMOD_SHIFT)
+				fl	|=	KBD_SHIFT;
+			if(event.key.keysym.mod & KMOD_ALT)
+				fl	|=	KBD_ALT;
+			if(event.key.keysym.mod & KMOD_CTRL)
+				fl	|=	KBD_CTRL;
+#endif
+			/* send keyb */
+			S_ON_DEBUG(fprintf(stderr, "KEY(%d) = %c&%d\n", k, key, fl););
+			if(fl & KBD_CTRL && sdl_keysyms[k].sym == SDLK_c)
+				sdl_GD(dev)->keyboard_handler(sdl_GD(dev), KBD_CTRL_C, 0);
+			else
+				sdl_GD(dev)->keyboard_handler(sdl_GD(dev), key, fl);
+                }break;
+	    case SDL_VIDEORESIZE:
+		/* new dims */
+		sdl_GD(dev)->size.x2	= event.resize.w;
+		sdl_GD(dev)->size.y2	= event.resize.h;
+		sdl_driver.x		= event.resize.w;
+		sdl_driver.y		= event.resize.h;
+		/* resize */
+		/* 
+		S_ON_DEBUG(fprintf(stderr, "RESIZE(%dx%d)\n", event.resize.w, event.resize.h));
+		*/
+		/* info resize */
+		sdl_GD(dev)->resize_handler(sdl_GD(dev));
+		break;
+/*
+	    case SDL_VIDEOEXPOSE:
+*/
+            case SDL_QUIT:
+                sdl_GD(dev)->keyboard_handler(sdl_GD(dev), KBD_CLOSE, 0);
+                break;
+	    default:
+		/* printf("Unhandled event: %d !\n", event.type); */
+		break;
+	}
+   }
+#undef event
+   sdl_SETUP_TIMER((void *)dev);
+   return;
+}
+
+static inline void sdl_update_sc(void *data)
+{
+	struct t_sdl_device_data	*dev	= NULL;
+
+	S_ON_DEBUG_TRACE("in");
+	
+	if (display_inactive)
+		return;
+		
+	/* assing struct */
+	if(data == NULL)
+		return;
+	dev	= (struct t_sdl_device_data *)data;
+
+	/* check if update neccesary */
+	if(dev == NULL || sdl_SURFACE(dev) == NULL)
+		return;
+	if(!sdl_UPENDING(dev))
+		return;
+
+	/* do update screen */
+/*	SDL_UpdateRect(sdl_SURFACE(dev), sdl_URECT(dev).x, sdl_URECT(dev).y, sdl_URECT(dev).w, sdl_URECT(dev).h);
+*/
+	SDL_UpdateRect(sdl_SURFACE(dev), 0, 0, 0, 0);
+	/* remove pending flag */
+	sdl_UPENDING(dev)	= 0;
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+
+/* quite stuppit function */
+#define sdl_NORM_UPDATE	0
+#define sdl_FULL_UPDATE 1
+static inline void sdl_register_update(struct t_sdl_device_data *dev, int x, int y, int w, int h, int opt)
+{
+	S_ON_DEBUG_TRACE("in");
+	sdl_UPENDING(dev)	= 1;
+	register_bottom_half(sdl_update_sc, dev);
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+/* partialy stolen from documentation :)
+   XXX: we can quite easily add here alpha blending :))) */
+static inline void sdl_putpixel(SDL_Surface *s, int x, int y, unsigned long pixel)
+{
+     Uint8 *p;
+
+     /* check our clip rect */
+     if(!((s->clip_rect.x < x && (s->clip_rect.x + s->clip_rect.w) > x) 
+			&& (s->clip_rect.y < y && (s->clip_rect.y + s->clip_rect.h) > y)))
+	return;
+     /* our sanity (fight int overflow :) */
+     pixel &= (1<<(s->format->BytesPerPixel)) - 1; 
+     /* our point */
+     p = (Uint8 *)s->pixels + y * s->pitch + x * s->format->BytesPerPixel;
+     switch(s->format->BytesPerPixel) {
+     case 1:
+         *p = pixel;
+         break;
+     case 2:
+         *(Uint16 *)p = pixel;
+         break;
+
+     case 3:
+         if(SDL_BYTEORDER == SDL_BIG_ENDIAN) {
+             p[0] = (pixel >> 16) & 0xff;
+             p[1] = (pixel >> 8) & 0xff;
+             p[2] = pixel & 0xff;
+         } else {
+             p[0] = pixel & 0xff;
+             p[1] = (pixel >> 8) & 0xff;
+             p[2] = (pixel >> 16) & 0xff;
+         }
+         break;
+     case 4:
+         *(Uint32 *)p = pixel;
+         break;
+     }
+     return;
+}
+
+
+/* DRIVER FUNCTIONS */
+
+/* init driver */
+u_char_t *sdl_init_driver(u_char_t *param, u_char_t *display)
+{
+	S_ON_DEBUG_TRACE("in");
+	/* init sdl video */
+	if(SDL_Init(SDL_INIT_VIDEO) != 0)
+		return (u_char_t *)stracpy((u_char_t *)SDL_GetError());
+	
+	/* fetch current video hw informations */
+	sdl_DATA.video_info		= (SDL_VideoInfo *) mem_alloc(sizeof(SDL_VideoInfo));
+	S_ASSERT(sdl_DATA.video_info != NULL);
+	memcpy(sdl_DATA.video_info, SDL_GetVideoInfo(), (sizeof(SDL_VideoInfo)));
+	/* fetch driver name */
+	sdl_DATA.video_drv		= (u_char_t *)mem_alloc(sizeof(u_char_t) * 11);
+	S_ASSERT(sdl_DATA.video_drv != NULL);
+	SDL_VideoDriverName((char *)sdl_DATA.video_drv, 11);
+
+	/*TODO: SDL_VideoModeOk() */
+
+	/* setup mode */
+	sdl_VIDEO_FLAGS		|= SDL_HWSURFACE | SDL_HWPALETTE | SDL_RLEACCEL | SDL_RESIZABLE;
+	sdl_VIDEO_WIDTH		= 320; /* ZIPIT_Z2 */
+	sdl_VIDEO_HEIGHT	= 240; /* ZIPIT_Z2 */
+	sdl_VIDEO_DEPTH		= sdl_DATA.video_info->vfmt->BitsPerPixel;
+
+	/* set driv config */
+	sdl_driver.x		= sdl_VIDEO_WIDTH;
+	sdl_driver.y		= sdl_VIDEO_HEIGHT;
+	sdl_driver.depth	= ((sdl_DATA.video_info->vfmt->BytesPerPixel & 0x7) |
+                           ((sdl_DATA.video_info->vfmt->BitsPerPixel & 0x1F) << 3));
+
+	/* create cursor :) (need nice one) */
+#ifdef sdl_HAVE_CURSOR
+	if(sdl_DATA.cursor == NULL)
+	{
+		/* sdl_DATA.cursor	= SDL_CreateCursor((void *)arrow, (void *)arrow, 32, 32, 0, 0);
+		*/
+		S_ASSERT(sdl_DATA.cursor != NULL);
+	}
+#endif
+	/* key repeat */
+#ifdef ZIPIT_Z2
+	/* On the zipit EnableUNICODE will pass the red keys in the .unicode field */
+	/* Then I can read the .unicode field instead of the raw .key and .mod. */
+	/* But that runs into trouble with the sticky keymap. */
+#endif
+	SDL_EnableUNICODE(1);
+	SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL);
+
+	S_ON_DEBUG(fprintf(stderr, "VIDEO(%s): %dx%dx%d [%d]\n", sdl_DATA.video_drv,
+						sdl_VIDEO_WIDTH, sdl_VIDEO_HEIGHT, sdl_VIDEO_DEPTH, sdl_driver.depth));
+	return NULL;
+}
+
+/* shutdown driver */
+void sdl_shutdown_driver()
+{
+	S_ON_DEBUG_TRACE("in");
+	sdl_KILL_TIMER();
+	sdl_DATA_FREE();
+	SDL_Quit();
+	return;
+}
+
+/* create new graph device */
+struct graphics_device *sdl_init_device()
+{
+	struct graphics_device *dev	= NULL;
+	struct t_sdl_device_data *data	= NULL;
+
+	S_ON_DEBUG_TRACE("in");
+
+	/* device data */
+	data			= (struct t_sdl_device_data *) mem_alloc(sizeof(struct t_sdl_device_data));
+	S_ASSERT(data != NULL);
+	memset(data, 0, sizeof(struct t_sdl_device_data));
+
+	/* init video mode */
+	sdl_SURFACE(data)	= SDL_SetVideoMode(sdl_VIDEO_WIDTH, sdl_VIDEO_HEIGHT, sdl_VIDEO_DEPTH, 
+							sdl_VIDEO_FLAGS);
+	if(sdl_SURFACE(data) == NULL)
+		return NULL;
+	SDL_SetAlpha(sdl_SURFACE(data), SDL_SRCALPHA, 0xff);
+
+	/* FIXME: here we shoulde re-update video info by calling SDL_VideoInfo() again */
+
+	/* alloc gd */
+	dev	= (struct graphics_device *) mem_alloc(sizeof(struct graphics_device));
+	S_ASSERT(dev != NULL);
+
+	/* setup gdS */
+	dev->size.x1		= 0;
+	dev->size.y1		= 0;
+	dev->size.x2		= sdl_VIDEO_WIDTH;
+	dev->size.y2		= sdl_VIDEO_HEIGHT;
+	dev->clip		= dev->size;
+
+	/*driver */
+	sdl_driver.flags	|= GD_NEED_CODEPAGE;
+	sdl_GD(data)		= dev;
+
+	/*driver */
+	//dev->drv		= &sdl_driver;
+	dev->driver_data	= (void *) data;
+	dev->user_data		= NULL;
+
+	/*set my cursor */
+	if(sdl_DATA.cursor != NULL)
+		SDL_SetCursor(sdl_DATA.cursor);
+
+	/*init timer */
+	if(sdl_DATA.event_timer == 0)
+		sdl_SETUP_TIMER((void *)data);
+	S_ON_DEBUG_TRACE("out");
+	return dev;
+}
+
+/* destroy device */
+void sdl_shutdown_device(struct graphics_device *drv)
+{
+	struct t_sdl_device_data *dev	= NULL;
+
+	S_ON_DEBUG_TRACE("in");
+	dev			= (struct t_sdl_device_data *) drv->driver_data;
+	S_ASSERT(dev != NULL);
+	
+	/* unregister bh */
+	unregister_bottom_half(sdl_update_sc, dev);
+
+	/* deinit video */
+	SDL_FreeSurface(sdl_SURFACE(dev));
+	sdl_SURFACE(dev)	= NULL;
+	mem_free(dev);
+	drv->driver_data	= NULL;
+	mem_free(drv);
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+/* get driver parameters 
+   XXX: what is this fx() for ??? */
+u_char_t *sdl_get_driver_param()
+{
+	S_ON_DEBUG_TRACE("in");
+	S_ASSERT(0);
+	return NULL;
+}
+
+/* GRAPHICS */
+
+/* create empty bitmap */
+int sdl_get_empty_bitmap(struct bitmap *bmp)
+{
+	SDL_Surface	*s	= NULL;
+
+	S_ON_DEBUG_TRACE("in");
+
+	/* null */
+	bmp->data	= bmp->flags	= bmp->user	= NULL;
+	bmp->skip	= 0;
+
+	/* alloc surface */
+	/* FIXED: ignoring byteorder here (taking from video info) */
+	s		= (SDL_Surface *)SDL_CreateRGBSurface(sdl_VIDEO_FLAGS, bmp->x, bmp->y, sdl_VIDEO_DEPTH,
+					sdl_DATA.video_info->vfmt->Rmask, sdl_DATA.video_info->vfmt->Gmask, 
+					sdl_DATA.video_info->vfmt->Bmask, sdl_DATA.video_info->vfmt->Amask);
+	S_ASSERT(s != NULL);
+
+	/* copy data */
+	bmp->data	= (void *)s->pixels;
+	bmp->skip	= s->pitch;
+	bmp->flags	= (void *)s;
+
+	/* lock if required */
+	if(SDL_MUSTLOCK(s))
+		SDL_LockSurface(s);
+	S_ON_DEBUG_TRACE("out");
+	return 0;
+}
+
+/* create filled bitmap */
+int sdl_get_filled_bitmap(struct bitmap *bmp, long color)
+{
+	S_ON_DEBUG_TRACE("in");
+	S_ASSERT(0);
+	return 0;
+}
+
+/* register bitmap */
+void sdl_register_bitmap(struct bitmap *bmp)
+{
+	SDL_Surface	*s	= NULL;
+
+	S_ON_DEBUG_TRACE("in");
+
+	/* unlock surface */
+	s	= (SDL_Surface *)bmp->flags;
+	if(SDL_MUSTLOCK(s))
+		SDL_UnlockSurface(s);
+	/* hide pixel mem */
+	bmp->data	= NULL;
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+
+/* prepare strip */
+void *sdl_prepare_strip(struct bitmap *bmp, int top, int lines)
+{
+	SDL_Surface	*s	= NULL;
+
+	S_ON_DEBUG_TRACE("in");
+
+	/* unlock surface */
+	s	= (SDL_Surface *)bmp->flags;
+	if(SDL_MUSTLOCK(s))
+		SDL_LockSurface(s);
+	S_ON_DEBUG_TRACE("out");
+	return (void *)(s->pixels + (top * s->pitch));
+}
+
+/* commit strip */
+void sdl_commit_strip(struct bitmap *bmp, int top, int lines)
+{
+	SDL_Surface	*s	= NULL;
+
+	S_ON_DEBUG_TRACE("in");
+
+	/* unlock surface */
+	s	= (SDL_Surface *)bmp->flags;
+	if(SDL_MUSTLOCK(s))
+		SDL_UnlockSurface(s);
+	return;
+}
+
+/* unregister bitmap */
+void sdl_unregister_bitmap(struct bitmap *bmp)
+{
+	SDL_Surface	*s	= NULL;
+
+	S_ON_DEBUG_TRACE("in");
+
+	s		= (SDL_Surface *)bmp->flags;
+	S_ASSERT(s != 0);
+	/* delete data */
+	SDL_FreeSurface(s);
+	/* null data */
+	bmp->data	= NULL;
+	bmp->flags	= NULL;
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+/* draw bmp */
+void sdl_draw_bitmap(struct graphics_device *drv, struct bitmap *bmp, int x, int y)
+{
+	SDL_Surface		 *s	= NULL;
+	struct t_sdl_device_data *dev	= NULL;
+	SDL_Rect	rect;
+
+	S_ON_DEBUG_TRACE("in");
+	dev	= (struct t_sdl_device_data *) drv->driver_data;
+	s	= (SDL_Surface *)bmp->flags;
+	memset(&rect, 0, sizeof(SDL_Rect));
+
+	/* blit :) */
+	rect.x	= x;
+	rect.y	= y;
+	SDL_BlitSurface(s, NULL, sdl_SURFACE(dev), &rect);
+	sdl_register_update(dev, rect.x, rect.y, rect.w, rect.h, 0);
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+/* draw more bmps */
+/*
+void sdl_draw_bitmaps(struct graphics_device *drv, struct bitmap **bmps, int n, int x, int y)
+{
+	int	i = 0;
+	struct t_sdl_device_data *dev	= NULL;
+	SDL_Rect rect;
+
+	S_ON_DEBUG_TRACE("in");
+	// check
+	if(n < 1)
+		return;
+
+	S_ON_DEBUG(fprintf(stderr, "draw_bitmaps(drv=%p, b=%p, n=%d,%d,%d)\n", drv, bmps, n,x,y));
+
+	dev	= (struct t_sdl_device_data *) drv->driver_data;
+	S_ON_DEBUG_TRACE("1");
+	memset(&rect, 0, sizeof(SDL_Rect));
+
+	// blit
+	rect.x	= x;
+	rect.y	= y;
+	for(i = 0; i < n; i++)
+	{
+	  	S_ON_DEBUG_TRACE("2");
+		SDL_BlitSurface((SDL_Surface *)bmps[i]->flags, NULL, sdl_SURFACE(dev), &rect);
+		rect.x	+=	bmps[i]->x;	
+	}
+	// FIXME: this should care about updating area, and possibly not update everythink
+	S_ON_DEBUG_TRACE("3");
+	sdl_register_update(dev, 0, 0, 0, 0, sdl_FULL_UPDATE);
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+*/
+/* get color */
+long sdl_get_color(int rgb)
+{
+	/*FIXME: not sure this is ok :) */
+	return SDL_MapRGB(sdl_DATA.video_info->vfmt, ((rgb >> 16) & 0xff), ((rgb >> 8) & 0xff), ((rgb) & 0xff));
+}
+
+/* fill some area */
+void sdl_fill_area(struct graphics_device *drv, int x1, int y1, int x2, int y2, long color)
+{
+	struct t_sdl_device_data *dev = NULL;
+	SDL_Rect rect;
+
+	S_ON_DEBUG_TRACE("in");
+	dev	= (struct t_sdl_device_data *) drv->driver_data;
+
+
+	rect.x	= x1;
+	rect.y	= y1;
+	rect.w	= x2 - x1;
+	rect.h	= y2 - y1;
+	if(SDL_MUSTLOCK(sdl_SURFACE(dev)))
+		SDL_LockSurface(sdl_SURFACE(dev));
+	SDL_FillRect(sdl_SURFACE(dev), &rect, color);
+	if(SDL_MUSTLOCK(sdl_SURFACE(dev)))
+		SDL_UnlockSurface(sdl_SURFACE(dev));
+	sdl_register_update(dev, rect.x, rect.y, rect.w, rect.h, 0);
+/*	sdl_register_update(dev, x1, y1, x2, y2, 0);
+*/
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+/* draw horizontal line */
+void sdl_draw_hline(struct graphics_device *drv, int left, int y, int right, long color)
+{
+	register int	i	= 0;
+	struct t_sdl_device_data *dev = NULL;
+
+	S_ON_DEBUG_TRACE("in");
+	dev	= (struct t_sdl_device_data *) drv->driver_data;
+	if(SDL_MUSTLOCK(sdl_SURFACE(dev)))
+		SDL_LockSurface(sdl_SURFACE(dev));
+	for(i = left; i < right; i++)
+		sdl_putpixel(sdl_SURFACE(dev), i, y, color);
+	if(SDL_MUSTLOCK(sdl_SURFACE(dev)))
+		SDL_UnlockSurface(sdl_SURFACE(dev));
+	sdl_register_update(dev,  left, y, 1, right - left, 0);
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+/* draw vertical line */
+void sdl_draw_vline(struct graphics_device *drv, int x, int top, int bottom, long color)
+{
+	register int i = 0;
+	struct t_sdl_device_data *dev = NULL;
+
+	S_ON_DEBUG_TRACE("in");
+	/* get ptr */
+	dev	= (struct t_sdl_device_data *) drv->driver_data;
+	if(SDL_MUSTLOCK(sdl_SURFACE(dev)))
+		SDL_LockSurface(sdl_SURFACE(dev));
+	for(i = top; i < bottom; i++)
+		sdl_putpixel(sdl_SURFACE(dev), x, i, color);
+	if(SDL_MUSTLOCK(sdl_SURFACE(dev)))
+		SDL_UnlockSurface(sdl_SURFACE(dev));
+	sdl_register_update(dev, x, top, bottom - top, 1, 0);
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+/* horizontal scroll */
+int sdl_hscroll(struct graphics_device *drv, struct rect_set **set, int sc)
+{
+	struct t_sdl_device_data *dev = NULL;
+	SDL_Rect rect1, rect2;
+
+	S_ON_DEBUG_TRACE("in");
+	dev	= (struct t_sdl_device_data *) drv->driver_data;
+
+	/* rect1 */
+	rect1.x = drv->clip.x1;
+	rect1.y = drv->clip.y1;
+	rect1.w = drv->clip.x2 - rect1.x;
+	rect1.h = drv->clip.y2 - rect1.y;
+
+	/* rect2 */
+	rect2.x = drv->clip.x1 + sc;
+	rect2.y = drv->clip.y1;
+	rect2.w = drv->clip.x2 - rect1.x;
+	rect2.h = drv->clip.y2 - rect1.y;
+
+	SDL_BlitSurface(sdl_SURFACE(dev), &rect1, sdl_SURFACE(dev), &rect2);
+	sdl_register_update(dev, rect1.x, rect1.y, rect1.w, rect1.h, 0);
+	S_ON_DEBUG_TRACE("out");
+	return 1;
+}
+
+/* vertical scroll */
+int sdl_vscroll(struct graphics_device *drv, struct rect_set **set, int sc)
+{
+	struct t_sdl_device_data *dev = NULL;
+	SDL_Rect rect1, rect2;
+
+	S_ON_DEBUG_TRACE("in");
+	/* get ptr */
+	dev	= (struct t_sdl_device_data *) drv->driver_data;
+
+	/* rect1 */
+	rect1.x = drv->clip.x1;
+	rect1.y = drv->clip.y1;
+	rect1.w = drv->clip.x2 - rect1.x;
+	rect1.h = drv->clip.y2 - rect1.y;
+
+	/* rect2 */
+	rect2.x = drv->clip.x1;
+	rect2.y = drv->clip.y1 + sc;
+	rect2.w = drv->clip.x2 - rect1.x;
+	rect2.h = drv->clip.y2 - rect1.y;
+
+	SDL_BlitSurface(sdl_SURFACE(dev), &rect1, sdl_SURFACE(dev), &rect2);
+	sdl_register_update(dev, rect1.x, rect1.y, rect1.w, rect1.h, 0);
+	S_ON_DEBUG_TRACE("out");
+	return 1;
+}
+
+/* set cliping area */
+void sdl_set_clip_area(struct graphics_device *drv, struct rect *r)
+{
+	struct t_sdl_device_data *dev = NULL;
+	SDL_Rect rect;
+
+	S_ON_DEBUG_TRACE("in");
+	/* get ptr */
+	dev	= (struct t_sdl_device_data *) drv->driver_data;
+	/* set rect */
+	rect.x	= r->x1;
+	rect.y	= r->y1;
+	rect.w	= r->x2 - r->x1;
+	rect.h	= r->y2 - r->y1;
+	/* dev clipp */
+	drv->clip	= *r;
+	/* clipp */
+	SDL_SetClipRect(sdl_SURFACE(dev), &rect);
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+
+/* block dev
+int sdl_block(struct graphics_device *drv)
+{
+	S_ON_DEBUG_TRACE("in");
+	S_ASSERT(0);
+	return 0;
+}
+*/
+
+
+/* unblock dev
+void sdl_unblock(struct graphics_device *drv)
+{
+	S_ON_DEBUG_TRACE("in");
+	S_ASSERT(0);
+	return;
+}
+*/
+
+/* set window title (tittle utf-8 encoded !!!!) */
+void sdl_set_title(struct graphics_device *drv, u_char_t *title)
+{
+	S_ON_DEBUG_TRACE("in");
+	SDL_WM_SetCaption((const char *)title, NULL);
+	return;
+}
+
+
+
+
+struct graphics_driver sdl_driver={
+	cast_uchar "sdl",
+	sdl_init_driver,
+	sdl_init_device,
+	sdl_shutdown_device,
+	sdl_shutdown_driver,
+	sdl_shutdown_driver,
+	NULL,
+	sdl_get_driver_param,
+	NULL,
+	NULL,
+	NULL,	
+	sdl_get_empty_bitmap,
+	sdl_register_bitmap,
+	sdl_prepare_strip,
+	sdl_commit_strip,
+	sdl_unregister_bitmap,
+	sdl_draw_bitmap,
+	sdl_get_color,	/* sdl_get_color */
+	sdl_fill_area,
+	sdl_draw_hline,
+	sdl_draw_vline,
+	sdl_hscroll,
+	sdl_vscroll,
+	sdl_set_clip_area,
+	dummy_block,
+	dummy_unblock,
+	NULL, /* sdl_set_title,*/	/* set_title */
+	NULL, /* exec */
+  	NULL,	 /*  set_clipboard_text */
+  	NULL,	 /*  get_clipboard_text */
+	0,				/* depth (filled in sdl_init_driver function) */
+	0, 0,				/* size (in X is empty) */
+	GD_NO_OS_SHELL,				/* flags */
+	0,				/* codepage */
+	NULL				/* shell */
+};
+
+#endif /* GRDRV_SDL */
diff -rupN links-2.3pre1.orig/sdl_data.inc links-2.3pre1/sdl_data.inc
--- links-2.3pre1.orig/sdl_data.inc	1969-12-31 19:00:00.000000000 -0500
+++ links-2.3pre1/sdl_data.inc	2012-06-22 09:42:27.000000000 -0400
@@ -0,0 +1,400 @@
+/**
+  sdl key syms
+
+  XXX: i'know this is stupit but i'm preparing for some good solution :)
+
+*/
+
+
+#ifndef _SDL_KEYS_INC
+#define _SDL_KEYS_INC
+
+#define ZIPIT_Z2 1
+
+struct t_sdl_keysym
+{
+	unsigned short	sym;
+	int		key;
+#ifdef ZIPIT_Z2
+        int		skey; 
+        int		akey; 
+        int		sakey;
+#endif
+};
+
+#ifdef ZIPIT_Z2
+/* dead key accent mappings for latin15 */
+int acute_map[] = {
+0xC1,'B','C','D',0xC9,'F','G','H',0xCD,'J','K','L','M','N',0xD3,'P','Q','R','S','T',0xDA,'V','W','X',0xDD,'Z',
+'\'',0,0,0,0,0,
+0xE1,'b','c','d',0xE9,'f','g','h',0xED,'j','k','l','m','n',0xF3,'p','q','r','s','t',0xFA,'v','w','x',0xFD,'z'};
+int grave_map[] = {
+0xC0,'B','C','D',0xC8,'F','G','H',0xCC,'J','K','L','M','N',0xD2,'P','Q','R','S','T',0xD9,'V','W','X','Y','Z',
+'`',0,0,0,0,0,
+0xE0,'b','c','d',0xE8,'f','g','h',0xEC,'j','k','l','m','n',0xF2,'p','q','r','s','t',0xF9,'v','w','x','y','z'};
+int circumflex_map[] = {
+0xC2,'B','C','D',0xCA,'F','G','H',0xCE,'J','K','L','M','N',0xD4,'P','Q','R','S','T',0xDB,'V','W','X','Y','Z',
+'^',0,0,0,0,0,
+0xE2,'b','c','d',0xEA,'f','g','h',0xEE,'j','k','l','m','n',0xF4,'p','q','r','s','t',0xFB,'v','w','x','y','z'};
+int diaeresis_map[] = {
+0xC4,'B','C','D',0xCB,'F','G','H',0xCF,'J','K','L','M','N',0xD6,'P','Q','R','S','T',0xDC,'V','W','X','Y','Z',
+'\"',0,0,0,0,0,
+0xE4,'b','c','d',0xEB,'f','g','h',0xEF,'j','k','l','m','n',0xF6,'p','q','r','s','t',0xFC,'v','w','x',0xFF,'z'};
+int cedilla_map[] = {
+'A','B',0xC7,'D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
+',',0,0,0,0,0,
+'a','b',0xE7,'d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
+int tilde_map[] = {
+0xC3,'B','C','D','E','F','G','H','I','J','K','L','M',0xD1,0xD5,'P','Q','R','S','T','U','V','W','X','Y','Z',
+'~',0,0,0,0,0,
+0xE3,'b','c','d','e','f','g','h','i','j','k','l','m',0xF1,0xF5,'p','q','r','s','t','u','v','w','x','y','z'};
+#endif
+
+/* big mapping SDL->LINKS */
+static struct t_sdl_keysym sdl_keysyms[] =
+{
+#ifdef ZIPIT_Z2
+	{ SDLK_UNKNOWN		,0 ,0, 0, 0},
+	{ SDLK_FIRST		,0 ,0, 0, 0},
+	{ SDLK_ESCAPE,KBD_ESC,KBD_ESC,'|',KBD_ESC},
+	{ SDLK_0,'0',')','0',')'},
+	{ SDLK_1,'1','!','1','!'},
+	{ SDLK_2,'2','@','2','@'},
+	{ SDLK_3,'3','#','3','#'},
+	{ SDLK_4,'4','$','4','$'},
+	{ SDLK_5,'5','%','5','%'},
+	{ SDLK_6,'6','^','6','^'},
+	{ SDLK_7,'7','&','7','&'},
+	{ SDLK_8,'8','*','8','*'},
+	{ SDLK_9,'9','(','9','('},
+	{ SDLK_a,'a','A','$','A'},
+	{ SDLK_b,'b','B','=','B'},
+	{ SDLK_c,'c','C','+','C'},
+	{ SDLK_d,'d','D','&','D'},
+	{ SDLK_e,'e','E','3','E'},
+	{ SDLK_f,'f','F','@','F'},
+	{ SDLK_g,'g','G','"','G'},
+	{ SDLK_h,'h','H','\'','`'},
+	{ SDLK_i,'i','I','8','I'},
+	{ SDLK_j,'j','J','[','J'},
+	{ SDLK_k,'k','K',']','`'},
+	{ SDLK_l,'l','L','-','|'},
+	{ SDLK_m,'m','M','?','%'},
+	{ SDLK_n,'n','N','_','N'},
+	{ SDLK_o,'o','O','9','O'},
+	{ SDLK_p,'p','P','0','P'},
+	{ SDLK_q,'q','Q','1','Q'},
+	{ SDLK_r,'r','R','4','R'},
+	{ SDLK_s,'s','S','#','S'},
+	{ SDLK_t,'t','T','5','T'},
+	{ SDLK_u,'u','U','7','U'},
+	{ SDLK_v,'v','V','*','V'},
+	{ SDLK_w,'w','W','2','W'},
+	{ SDLK_x,'x','X','/','\\'},
+	{ SDLK_y,'y','Y','6','Y'},
+	{ SDLK_z,'z','Z','!','C'},
+	{ SDLK_MINUS,'-','_','-','_'},
+	{ SDLK_EQUALS,'=','+','=','+'},
+	{ SDLK_LEFTBRACKET,'[','{','[','{'},
+	{ SDLK_RIGHTBRACKET,']','}',']','}'},
+	{ SDLK_SEMICOLON,';','~',':','^'},
+	{ SDLK_QUOTE,'\'','"','\'','"'},
+	{ SDLK_BACKSLASH,'\\','|','\\','|'},
+	{ SDLK_SLASH,'/','?','/','?'},
+	{ SDLK_PERIOD,'.',')','>','}'},
+	{ SDLK_COMMA,',','(','<','{'},
+	{ SDLK_BACKQUOTE,'`','~','`','~'},
+	{ SDLK_BACKSPACE,KBD_BS,KBD_BS,KBD_BS,KBD_BS},
+	{ SDLK_TAB,KBD_TAB,KBD_TAB,'~',KBD_TAB},
+	{ SDLK_DELETE,127,127,127,127},
+	{ SDLK_RETURN,KBD_ENTER,KBD_ENTER,KBD_ENTER,KBD_ENTER},
+	{ SDLK_F1,KBD_F1,KBD_F1,KBD_F1,KBD_F1},
+	{ SDLK_F2,KBD_F2,KBD_F2,KBD_F2,KBD_F2},
+	{ SDLK_F3,KBD_F3,KBD_F3,KBD_F3,KBD_F3},
+	{ SDLK_F4,KBD_F4,KBD_F4,KBD_F4,KBD_F4},
+	{ SDLK_F5,KBD_F5,KBD_F5,KBD_F5,KBD_F5},
+	{ SDLK_F6,KBD_F6,KBD_F6,KBD_F6,KBD_F6},
+	{ SDLK_F7,KBD_F7,KBD_F7,KBD_F7,KBD_F7},
+	{ SDLK_F8,KBD_F8,KBD_F8,KBD_F8,KBD_F8},
+	{ SDLK_F9,KBD_F9,KBD_F9,KBD_F9,KBD_F9},
+	{ SDLK_F10,KBD_F10,KBD_F10,KBD_F10,KBD_F10},
+	{ SDLK_ESCAPE,0x1b,0x1b,'|',0x1b},
+
+	{ SDLK_LEFT,KBD_LEFT,KBD_LEFT,KBD_LEFT,KBD_LEFT},
+	{ SDLK_RIGHT,KBD_RIGHT,KBD_RIGHT,KBD_RIGHT,KBD_RIGHT},
+	{ SDLK_UP,KBD_UP,KBD_UP,KBD_UP,KBD_UP},
+	{ SDLK_DOWN,KBD_DOWN,KBD_DOWN,KBD_DOWN,KBD_DOWN},
+//	{ SDLK_PAGEUP,KBD_PAGE_UP,KBD_PAGE_UP,']', KBD_PAGE_UP},
+//	{ SDLK_PAGEDOWN,KBD_PAGE_DOWN,KBD_PAGE_DOWN, '[', KBD_PAGE_DOWN},
+//      The [] was a hack for left/rt, but INS/DEL for scroll is a better fit.
+	{ SDLK_PAGEUP,KBD_PAGE_UP,KBD_PAGE_UP,KBD_INS, KBD_INS},
+	{ SDLK_PAGEDOWN,KBD_PAGE_DOWN,KBD_PAGE_DOWN, KBD_DEL, KBD_DEL},
+	{ SDLK_SPACE,' ',' ',' ',' '},
+	{ SDLK_HOME,KBD_HOME,KBD_HOME,KBD_PAGE_UP,KBD_PAGE_UP},
+	{ SDLK_END,KBD_END,KBD_END,KBD_PAGE_DOWN,KBD_PAGE_DOWN},
+
+	{ SDLK_LALT,308,308,308,308},
+	{ SDLK_RALT,307,307,307,307},
+	{ SDLK_LCTRL,306,306,306,306},
+	{ SDLK_RCTRL,305,305,305,305},
+	{ SDLK_LSHIFT,304,304,304,304},
+	{ SDLK_RSHIFT,303,303,303,303},
+  { SDLK_LAST		,0 ,0, 0, 0},
+#else
+	{ SDLK_UNKNOWN		,0 },
+	{ SDLK_FIRST		,0 },
+	{ SDLK_BACKSPACE	,KBD_BS },
+	{ SDLK_TAB		,KBD_TAB },
+	{ SDLK_CLEAR		,12 },
+	{ SDLK_RETURN		,KBD_ENTER },
+	{ SDLK_PAUSE		,19 },
+	{ SDLK_ESCAPE		,KBD_ESC },
+	{ SDLK_SPACE		,32 },
+	{ SDLK_EXCLAIM		,33 },
+	{ SDLK_QUOTEDBL		,34 },
+	{ SDLK_HASH		,35 },
+	{ SDLK_DOLLAR		,36 },
+	{ SDLK_AMPERSAND		,38 },
+	{ SDLK_QUOTE		,39 },
+	{ SDLK_LEFTPAREN		,40 },
+	{ SDLK_RIGHTPAREN		,41 },
+	{ SDLK_ASTERISK		,42 },
+	{ SDLK_PLUS		,43 },
+	{ SDLK_COMMA		,44 },
+	{ SDLK_MINUS		,45 },
+	{ SDLK_PERIOD		,46 },
+	{ SDLK_SLASH		,47 },
+	{ SDLK_0			,48 },
+	{ SDLK_1			,49 },
+	{ SDLK_2			,50 },
+	{ SDLK_3			,51 },
+	{ SDLK_4			,52 },
+	{ SDLK_5			,53 },
+	{ SDLK_6			,54 },
+	{ SDLK_7			,55 },
+	{ SDLK_8			,56 },
+	{ SDLK_9			,57 },
+	{ SDLK_COLON		,58 },
+	{ SDLK_SEMICOLON		,59 },
+	{ SDLK_LESS		,60 },
+	{ SDLK_EQUALS		,61 },
+	{ SDLK_GREATER		,62 },
+	{ SDLK_QUESTION		,63 },
+	{ SDLK_AT			,64 },
+	/* 
+	   Skip uppercase letters
+	 */
+	{ SDLK_LEFTBRACKET	,91 },
+	{ SDLK_BACKSLASH		,92 },
+	{ SDLK_RIGHTBRACKET	,93 },
+	{ SDLK_CARET		,94 },
+	{ SDLK_UNDERSCORE		,95 },
+	{ SDLK_BACKQUOTE		,96 },
+	{ SDLK_a			,97 },
+	{ SDLK_b			,98 },
+	{ SDLK_c			,99 },
+	{ SDLK_d			,100 },
+	{ SDLK_e			,101 },
+	{ SDLK_f			,102 },
+	{ SDLK_g			,103 },
+	{ SDLK_h			,104 },
+	{ SDLK_i			,105 },
+	{ SDLK_j			,106 },
+	{ SDLK_k			,107 },
+	{ SDLK_l			,108 },
+	{ SDLK_m			,109 },
+	{ SDLK_n			,110 },
+	{ SDLK_o			,111 },
+	{ SDLK_p			,112 },
+	{ SDLK_q			,113 },
+	{ SDLK_r			,114 },
+	{ SDLK_s			,115 },
+	{ SDLK_t			,116 },
+	{ SDLK_u			,117 },
+	{ SDLK_v			,118 },
+	{ SDLK_w			,119 },
+	{ SDLK_x			,120 },
+	{ SDLK_y			,121 },
+	{ SDLK_z			,122 },
+	{ SDLK_DELETE		,127 },
+	/* End of ASCII mapped keysyms */
+
+	/* International keyboard syms */
+	{ SDLK_WORLD_0		,160 },		/* 0xA0 */
+	{ SDLK_WORLD_1		,161 },
+	{ SDLK_WORLD_2		,162 },
+	{ SDLK_WORLD_3		,163 },
+	{ SDLK_WORLD_4		,164 },
+	{ SDLK_WORLD_5		,165 },
+	{ SDLK_WORLD_6		,166 },
+	{ SDLK_WORLD_7		,167 },
+	{ SDLK_WORLD_8		,168 },
+	{ SDLK_WORLD_9		,169 },
+	{ SDLK_WORLD_10		,170 },
+	{ SDLK_WORLD_11		,171 },
+	{ SDLK_WORLD_12		,172 },
+	{ SDLK_WORLD_13		,173 },
+	{ SDLK_WORLD_14		,174 },
+	{ SDLK_WORLD_15		,175 },
+	{ SDLK_WORLD_16		,176 },
+	{ SDLK_WORLD_17		,177 },
+	{ SDLK_WORLD_18		,178 },
+	{ SDLK_WORLD_19		,179 },
+	{ SDLK_WORLD_20		,180 },
+	{ SDLK_WORLD_21		,181 },
+	{ SDLK_WORLD_22		,182 },
+	{ SDLK_WORLD_23		,183 },
+	{ SDLK_WORLD_24		,184 },
+	{ SDLK_WORLD_25		,185 },
+	{ SDLK_WORLD_26		,186 },
+	{ SDLK_WORLD_27		,187 },
+	{ SDLK_WORLD_28		,188 },
+	{ SDLK_WORLD_29		,189 },
+	{ SDLK_WORLD_30		,190 },
+	{ SDLK_WORLD_31		,191 },
+	{ SDLK_WORLD_32		,192 },
+	{ SDLK_WORLD_33		,193 },
+	{ SDLK_WORLD_34		,194 },
+	{ SDLK_WORLD_35		,195 },
+	{ SDLK_WORLD_36		,196 },
+	{ SDLK_WORLD_37		,197 },
+	{ SDLK_WORLD_38		,198 },
+	{ SDLK_WORLD_39		,199 },
+	{ SDLK_WORLD_40		,200 },
+	{ SDLK_WORLD_41		,201 },
+	{ SDLK_WORLD_42		,202 },
+	{ SDLK_WORLD_43		,203 },
+	{ SDLK_WORLD_44		,204 },
+	{ SDLK_WORLD_45		,205 },
+	{ SDLK_WORLD_46		,206 },
+	{ SDLK_WORLD_47		,207 },
+	{ SDLK_WORLD_48		,208 },
+	{ SDLK_WORLD_49		,209 },
+	{ SDLK_WORLD_50		,210 },
+	{ SDLK_WORLD_51		,211 },
+	{ SDLK_WORLD_52		,212 },
+	{ SDLK_WORLD_53		,213 },
+	{ SDLK_WORLD_54		,214 },
+	{ SDLK_WORLD_55		,215 },
+	{ SDLK_WORLD_56		,216 },
+	{ SDLK_WORLD_57		,217 },
+	{ SDLK_WORLD_58		,218 },
+	{ SDLK_WORLD_59		,219 },
+	{ SDLK_WORLD_60		,220 },
+	{ SDLK_WORLD_61		,221 },
+	{ SDLK_WORLD_62		,222 },
+	{ SDLK_WORLD_63		,223 },
+	{ SDLK_WORLD_64		,224 },
+	{ SDLK_WORLD_65		,225 },
+	{ SDLK_WORLD_66		,226 },
+	{ SDLK_WORLD_67		,227 },
+	{ SDLK_WORLD_68		,228 },
+	{ SDLK_WORLD_69		,229 },
+	{ SDLK_WORLD_70		,230 },
+	{ SDLK_WORLD_71		,231 },
+	{ SDLK_WORLD_72		,232 },
+	{ SDLK_WORLD_73		,233 },
+	{ SDLK_WORLD_74		,234 },
+	{ SDLK_WORLD_75		,235 },
+	{ SDLK_WORLD_76		,236 },
+	{ SDLK_WORLD_77		,237 },
+	{ SDLK_WORLD_78		,238 },
+	{ SDLK_WORLD_79		,239 },
+	{ SDLK_WORLD_80		,240 },
+	{ SDLK_WORLD_81		,241 },
+	{ SDLK_WORLD_82		,242 },
+	{ SDLK_WORLD_83		,243 },
+	{ SDLK_WORLD_84		,244 },
+	{ SDLK_WORLD_85		,245 },
+	{ SDLK_WORLD_86		,246 },
+	{ SDLK_WORLD_87		,247 },
+	{ SDLK_WORLD_88		,248 },
+	{ SDLK_WORLD_89		,249 },
+	{ SDLK_WORLD_90		,250 },
+	{ SDLK_WORLD_91		,251 },
+	{ SDLK_WORLD_92		,252 },
+	{ SDLK_WORLD_93		,253 },
+	{ SDLK_WORLD_94		,254 },
+	{ SDLK_WORLD_95		,255 },		/* 0xFF */
+
+	/* Numeric keypad */
+	{ SDLK_KP0		,256 },
+	{ SDLK_KP1		,257 },
+	{ SDLK_KP2		,258 },
+	{ SDLK_KP3		,259 },
+	{ SDLK_KP4		,260 },
+	{ SDLK_KP5		,261 },
+	{ SDLK_KP6		,262 },
+	{ SDLK_KP7		,263 },
+	{ SDLK_KP8		,264 },
+	{ SDLK_KP9		,265 },
+	{ SDLK_KP_PERIOD	,266 },
+	{ SDLK_KP_DIVIDE	,267 },
+	{ SDLK_KP_MULTIPLY	,268 },
+	{ SDLK_KP_MINUS		,269 },
+	{ SDLK_KP_PLUS		,270 },
+	{ SDLK_KP_ENTER		,KBD_ENTER },
+	{ SDLK_KP_EQUALS	,272 },
+
+	/* Arrows + Home/End pad */
+	{ SDLK_UP		,KBD_UP },
+	{ SDLK_DOWN		,KBD_DOWN },
+	{ SDLK_RIGHT		,KBD_RIGHT },
+	{ SDLK_LEFT		,KBD_LEFT },
+	{ SDLK_INSERT		,KBD_INS },
+	{ SDLK_HOME		,KBD_HOME },
+	{ SDLK_END		,KBD_END },
+	{ SDLK_PAGEUP		,KBD_PAGE_UP },
+	{ SDLK_PAGEDOWN		,KBD_PAGE_DOWN },
+
+	/* Function keys */
+	{ SDLK_F1		,KBD_F1 },
+	{ SDLK_F2		,KBD_F2 },
+	{ SDLK_F3		,KBD_F3 },
+	{ SDLK_F4		,KBD_F4 },
+	{ SDLK_F5		,KBD_F5 },
+	{ SDLK_F6		,KBD_F6 },
+	{ SDLK_F7		,KBD_F7 },
+	{ SDLK_F8		,KBD_F8 },
+	{ SDLK_F9		,KBD_F9 },
+	{ SDLK_F10		,KBD_F10 },
+	{ SDLK_F11		,KBD_F11 },
+	{ SDLK_F12		,KBD_F12 },
+	{ SDLK_F13		,294 },
+	{ SDLK_F14		,295 },
+	{ SDLK_F15		,296 },
+
+	/* Key state modifier keys */
+	{ SDLK_NUMLOCK		,300 },
+	{ SDLK_CAPSLOCK		,301 },
+	{ SDLK_SCROLLOCK		,302 },
+	{ SDLK_RSHIFT		,303 },
+	{ SDLK_LSHIFT		,304 },
+	{ SDLK_RCTRL		,305 },
+	{ SDLK_LCTRL		,306 },
+	{ SDLK_RALT		,307 },
+	{ SDLK_LALT		,308 },
+	{ SDLK_RMETA		,309 },
+	{ SDLK_LMETA		,310 },
+	{ SDLK_LSUPER		,311 },		/* Left "Windows" key */
+	{ SDLK_RSUPER		,312 },		/* Right "Windows" key */
+	{ SDLK_MODE		,313 },		/* "Alt Gr" key */
+	{ SDLK_COMPOSE		,314 },		/* Multi-key compose key */
+
+	/* Miscellaneous function keys */
+	{ SDLK_HELP		,315 },
+	{ SDLK_PRINT		,316 },
+	{ SDLK_SYSREQ		,317 },
+	{ SDLK_BREAK		,318 },
+	{ SDLK_MENU		,KBD_F9 },
+	{ SDLK_POWER		,320 },		/* Power Macintosh power key */
+	{ SDLK_EURO		,321 },		/* Some european keyboards */
+	{ SDLK_UNDO		,322 },		/* Atari keyboard has Undo */
+
+	/* Add any other keys here */
+
+	{ SDLK_LAST		,0  },
+#endif
+};
+
+#endif
--- links-2.12.unmodified/Makefile.am
+++ links-2.12/Makefile.am
@@ -13,7 +13,7 @@
 else
 endif
 
-links_SOURCES=af_unix.c auth.c beos.c bfu.c block.c bookmark.c cache.c charsets.c compress.c connect.c cookies.c data.c default.c dip.c directfb.c dither.c dns.c dos.c drivers.c error.c file.c finger.c fn_impl.c font_inc.c framebuf.c ftp.c gif.c grx.c hpux.c html.c html_gr.c html_r.c html_tbl.c http.c https.c img.c imgcache.c jpeg.c jsint.c kbd.c language.c listedit.c lru.c mailto.c main.c memory.c menu.c objreq.c os_dep.c pmshell.c png.c sched.c select.c session.c smb.c string.c svg.c svgalib.c terminal.c tiff.c types.c url.c view.c view_gr.c vms.c x.c xbm.c beos.h bits.h cfg.h codepage.h com-defs.h config-vms.h dfb_cur.h hpux.h language.h links.h os_dep.h os_depx.h setup.h arrow.inc codepage.inc entity.inc fbcommon.inc language.inc links_ic.inc uni_7b.inc upcase.inc vpipe.inc
+links_SOURCES=af_unix.c auth.c beos.c bfu.c block.c bookmark.c cache.c charsets.c compress.c connect.c cookies.c data.c default.c dip.c directfb.c dither.c dns.c dos.c drivers.c error.c file.c finger.c fn_impl.c font_inc.c framebuf.c ftp.c gif.c grx.c hpux.c html.c html_gr.c html_r.c html_tbl.c http.c https.c img.c imgcache.c jpeg.c jsint.c kbd.c language.c listedit.c lru.c mailto.c main.c memory.c menu.c objreq.c os_dep.c pmshell.c png.c sched.c sdl.c select.c session.c smb.c string.c svg.c svgalib.c terminal.c tiff.c types.c url.c view.c view_gr.c vms.c x.c xbm.c beos.h bits.h cfg.h codepage.h com-defs.h config-vms.h dfb_cur.h hpux.h language.h links.h os_dep.h os_depx.h setup.h arrow.inc codepage.inc entity.inc fbcommon.inc language.inc links_ic.inc uni_7b.inc upcase.inc vpipe.inc
 
 dist-hook:
 #remove the symlinka:
--- links-2.12.unmodified/Makefile.in
+++ links-2.12/Makefile.in
@@ -66,6 +66,7 @@
 MAKEINFO = @MAKEINFO@
 PACKAGE = @PACKAGE@
 PKG_CONFIG = @PKG_CONFIG@
+SDL_CONFIG = @SDL_CONFIG@
 VERSION = @VERSION@
 
 man_MANS = links.1
@@ -76,7 +77,7 @@
 
 @ATHEOS_GR_TRUE@links_LDADD = atheos.o
 
-links_SOURCES = af_unix.c auth.c beos.c bfu.c block.c bookmark.c cache.c charsets.c compress.c connect.c cookies.c data.c default.c dip.c directfb.c dither.c dns.c dos.c drivers.c error.c file.c finger.c fn_impl.c font_inc.c framebuf.c ftp.c gif.c grx.c hpux.c html.c html_gr.c html_r.c html_tbl.c http.c https.c img.c imgcache.c jpeg.c jsint.c kbd.c language.c listedit.c lru.c mailto.c main.c memory.c menu.c objreq.c os_dep.c pmshell.c png.c sched.c select.c session.c smb.c string.c svg.c svgalib.c terminal.c tiff.c types.c url.c view.c view_gr.c vms.c x.c xbm.c beos.h bits.h cfg.h codepage.h com-defs.h config-vms.h dfb_cur.h hpux.h language.h links.h os_dep.h os_depx.h setup.h arrow.inc codepage.inc entity.inc fbcommon.inc language.inc links_ic.inc uni_7b.inc upcase.inc vpipe.inc
+links_SOURCES = af_unix.c auth.c beos.c bfu.c block.c bookmark.c cache.c charsets.c compress.c connect.c cookies.c data.c default.c dip.c directfb.c dither.c dns.c dos.c drivers.c error.c file.c finger.c fn_impl.c font_inc.c framebuf.c ftp.c gif.c grx.c hpux.c html.c html_gr.c html_r.c html_tbl.c http.c https.c img.c imgcache.c jpeg.c jsint.c kbd.c language.c listedit.c lru.c mailto.c main.c memory.c menu.c objreq.c os_dep.c pmshell.c png.c sched.c select.c session.c smb.c string.c svg.c svgalib.c terminal.c tiff.c types.c url.c view.c view_gr.c vms.c x.c xbm.c beos.h bits.h cfg.h codepage.h com-defs.h config-vms.h dfb_cur.h hpux.h language.h links.h os_dep.h os_depx.h setup.h arrow.inc codepage.inc entity.inc fbcommon.inc language.inc links_ic.inc uni_7b.inc upcase.inc vpipe.inc sdl.c
 
 CXXFLAGS = @CXXFLAGS@
 
@@ -91,19 +92,19 @@
 
 DEFS = @DEFS@ -I. -I$(srcdir) -I.
 CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
+LDFLAGS = @LDFLAGS@ -L.
 links_OBJECTS =  af_unix.o auth.o beos.o bfu.o block.o bookmark.o \
 cache.o charsets.o compress.o connect.o cookies.o data.o default.o \
 dip.o directfb.o dither.o dns.o dos.o drivers.o error.o file.o finger.o \
 fn_impl.o font_inc.o framebuf.o ftp.o gif.o grx.o hpux.o html.o \
 html_gr.o html_r.o html_tbl.o http.o https.o img.o imgcache.o jpeg.o \
 jsint.o kbd.o language.o listedit.o lru.o mailto.o main.o memory.o \
-menu.o objreq.o os_dep.o pmshell.o png.o sched.o select.o session.o \
+menu.o objreq.o os_dep.o pmshell.o png.o sched.o sdl.o select.o session.o \
 smb.o string.o svg.o svgalib.o terminal.o tiff.o types.o url.o view.o \
 view_gr.o vms.o x.o xbm.o
 @ATHEOS_GR_TRUE@links_DEPENDENCIES =  atheos.o
-links_LDFLAGS = 
-CFLAGS = @CFLAGS@
+links_LDFLAGS = -Wl,--gc-sections,--print-gc-sections
+CFLAGS = @CFLAGS@ -fpic -fdata-sections -ffunction-sections
 COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@
@@ -188,6 +189,7 @@
 	     $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed 's/$(EXEEXT)$$//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`; \
 	  else :; fi; \
 	done
+
 
 uninstall-binPROGRAMS:
 	@$(NORMAL_UNINSTALL)
@@ -445,6 +447,8 @@
 	setup.h language.h codepage.h
 sched.o: sched.c links.h cfg.h config.h com-defs.h os_dep.h os_depx.h \
 	setup.h language.h codepage.h
+sdl.o: sdl.c links.h cfg.h config.h com-defs.h os_dep.h os_depx.h setup.h \
+	language.h codepage.h sdl_data.inc
 select.o: select.c links.h cfg.h config.h com-defs.h os_dep.h os_depx.h \
 	setup.h language.h codepage.h
 session.o: session.c links.h cfg.h config.h com-defs.h os_dep.h \
 --- links-2.12.unmodified/configure
+++ links-2.12/configure
@@ -54,6 +54,8 @@
 ac_help="$ac_help
   --without-directfb      compile without DirectFB graphics driver"
 ac_help="$ac_help
+  --without-sdl           compile without SDL graphics driver"
+ac_help="$ac_help
   --without-pmshell       compile without PMShell graphics driver"
 ac_help="$ac_help
   --without-windows       compile without Windows graphics driver"
@@ -6955,6 +6957,11 @@
   if test "$withval" = no; then disable_directfb=yes; else disable_directfb=no; fi
 fi
 
+# Check whether --with-sdl or --without-sdl was given.
+if test "${with_sdl+set}" = set; then
+  withval="$with_sdl"
+if test "$withval" = no; then disable_sdl=yes; else disable_sdl=no; fi
+fi
 # Check whether --with-pmshell or --without-pmshell was given.
 if test "${with_pmshell+set}" = set; then
   withval="$with_pmshell"
@@ -8068,6 +8075,142 @@
 fi
 
 
+if test "$disable_sdl" != yes ; then
+	# Extract the first word of "sdl-config", so it can be a program name with args.
+set dummy sdl-config; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_path_SDL_CONFIG+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $SDL_CONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_SDL_CONFIG="$SDL_CONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_SDL_CONFIG="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_SDL_CONFIG" && ac_cv_path_SDL_CONFIG="no"
+  ;;
+esac
+fi
+SDL_CONFIG=$ac_cv_path_SDL_CONFIG
+if test -n "$SDL_CONFIG"; then
+  { echo "$as_me:$LINENO: result: $SDL_CONFIG" >&5
+echo "${ECHO_T}$SDL_CONFIG" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+	if test "$SDL_CONFIG" != "no"; then
+	        { echo "$as_me:$LINENO: checking for SDL >= 1.2.0" >&5
+echo $ECHO_N "checking for SDL >= 1.2.0... $ECHO_C" >&6; }
+        	sdl_version="`$SDL_CONFIG --version`"
+		if expr "$sdl_version" \>= 1.2.0 >/dev/null; then
+			{ echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6; }
+			SDL_CFLAGS="`$SDL_CONFIG --cflags`"
+			SDL_LIBS="`$SDL_CONFIG --libs`"
+	           	cat >>confdefs.h <<\_ACEOF
+#define GRDRV_SDL 1
+_ACEOF
+
+        	   	drivers="$drivers SDL"
+			CPPFLAGS="$CPPFLAGS $SDL_CFLAGS"
+
+{ echo "$as_me:$LINENO: checking for XextAddDisplay in -lXext" >&5
+echo $ECHO_N "checking for XextAddDisplay in -lXext... $ECHO_C" >&6; }
+if test "${ac_cv_lib_Xext_XextAddDisplay+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lXext  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XextAddDisplay ();
+int
+main ()
+{
+return XextAddDisplay ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext &&
+       $as_test_x conftest$ac_exeext; then
+  ac_cv_lib_Xext_XextAddDisplay=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_Xext_XextAddDisplay=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_lib_Xext_XextAddDisplay" >&5
+echo "${ECHO_T}$ac_cv_lib_Xext_XextAddDisplay" >&6; }
+if test $ac_cv_lib_Xext_XextAddDisplay = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBXEXT 1
+_ACEOF
+
+  LIBS="-lXext $LIBS"
+
+fi
+
+			LIBS="$SDL_LIBS $LIBS"
+		else
+			{ echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+		fi
+	fi
+fi
+
 if test "$disable_pmshell" != yes && test "$ac_cv_header_sys_fmutex_h" = yes && test "$ac_cv_have_beginthread" = yes; then
 	echo $ac_n "checking for pmshell""... $ac_c" 1>&6
 echo "configure:8064: checking for pmshell" >&5
@@ -10040,6 +10183,7 @@
 s%@DIRECTFB_CONFIG@%$DIRECTFB_CONFIG%g
 s%@DIRECTFB_CFLAGS@%$DIRECTFB_CFLAGS%g
 s%@DIRECTFB_LIBS@%$DIRECTFB_LIBS%g
+s%SDL_CONFIG@%$SDL_CONFIG%g
 s%@CXX@%$CXX%g
 s%@LIBPNG_CFLAGS@%$LIBPNG_CFLAGS%g
 s%@LIBPNG_LIBS@%$LIBPNG_LIBS%g
--- links-2.12.unmodified/configure.in
+++ links-2.12/configure.in
@@ -17,7 +17,7 @@
 dnl Checks for programs.
 AC_PROG_CC
 
-dnl AC_PROG_CXX
+AC_PROG_CXX
 dnl AC_PROG_AWK
 dnl AM_PROG_LEX
 dnl AC_PROG_YACC
@@ -865,7 +865,7 @@
 AC_ARG_WITH(x, [  --without-x             compile without X Window System graphics driver],[if test "$withval" = no; then disable_x=yes; else disable_x=no; fi])
 AC_ARG_WITH(fb, [  --without-fb            compile without Linux Framebuffer graphics driver],[if test "$withval" = no; then disable_fb=yes; else disable_fb=no; fi])
 AC_ARG_WITH(directfb, [  --without-directfb      compile without DirectFB graphics driver],[if test "$withval" = no; then disable_directfb=yes; else disable_directfb=no; fi])
-dnl AC_ARG_WITH(sdl, [  --without-sdl           compile without SDL graphics driver],[if test "$withval" = no; then disable_sdl=yes; else disable_sdl=no; fi])
+AC_ARG_WITH(sdl, [  --without-sdl           compile without SDL graphics driver],[if test "$withval" = no; then disable_sdl=yes; else disable_sdl=no; fi])
 AC_ARG_WITH(pmshell, [  --without-pmshell       compile without PMShell graphics driver],[if test "$withval" = no; then disable_pmshell=yes; else disable_pmshell=no; fi])
 AC_ARG_WITH(windows, [  --without-windows       compile without Windows graphics driver],[if test "$withval" = no; then disable_windows=yes; else disable_windows=no; fi])
 AC_ARG_WITH(atheos, [  --without-atheos        compile without Atheos graphics driver],[if test "$withval" = no; then disable_atheos=yes; else disable_atheos; fi])
@@ -983,25 +983,25 @@
 	fi
 fi
 
-dnl if test "$disable_sdl" != yes; then
-dnl 	AC_PATH_PROG(SDL_CONFIG, sdl-config, no)
-dnl 	if test "$SDL_CONFIG" != "no"; then
-dnl 	        AC_MSG_CHECKING(for SDL >= 1.2.0)
-dnl         	sdl_version="`$SDL_CONFIG --version`"
-dnl 		if expr "$sdl_version" \>= 1.2.0 >/dev/null; then
-dnl 			AC_MSG_RESULT(yes)
-dnl 			SDL_CFLAGS="`$SDL_CONFIG --cflags`"
-dnl 			SDL_LIBS="`$SDL_CONFIG --libs`"
-dnl 	           	AC_DEFINE(GRDRV_SDL)
-dnl         	   	drivers="$drivers SDL"
-dnl 			CPPFLAGS="$CPPFLAGS $SDL_CFLAGS"
-dnl 			AC_CHECK_LIB(Xext, XextAddDisplay)
-dnl 			LIBS="$SDL_LIBS $LIBS"
-dnl 		else
-dnl 			AC_MSG_RESULT(no)
-dnl 		fi
-dnl 	fi
-dnl fi
+if test "$disable_sdl" != yes; then
+ 	AC_PATH_PROG(SDL_CONFIG, sdl-config, no)
+ 	if test "$SDL_CONFIG" != "no"; then
+ 	        AC_MSG_CHECKING(for SDL >= 1.2.0)
+         	sdl_version="`$SDL_CONFIG --version`"
+ 		if expr "$sdl_version" \>= 1.2.0 >/dev/null; then
+ 			AC_MSG_RESULT(yes)
+ 			SDL_CFLAGS="`$SDL_CONFIG --cflags`"
+ 			SDL_LIBS="`$SDL_CONFIG --libs`"
+ 	           	AC_DEFINE(GRDRV_SDL)
+         	   	drivers="$drivers SDL"
+ 			CPPFLAGS="$CPPFLAGS $SDL_CFLAGS"
+ 			AC_CHECK_LIB(Xext, XextAddDisplay)
+ 			LIBS="$SDL_LIBS $LIBS"
+ 		else
+ 			AC_MSG_RESULT(no)
+ 		fi
+ 	fi
+fi
 
 if test "$disable_pmshell" != yes && test "$ac_cv_header_sys_fmutex_h" = yes && test "$ac_cv_have_beginthread" = yes; then
 	AC_CACHE_CHECK([for pmshell], ac_cv_have_pmshell,
--- links-2.12.unmodified/links.h
+++ links-2.12/links.h
@@ -467,7 +467,7 @@
 #ifndef G
 #define F 0
 #else
-extern int F;
+extern int F; //tells us what mode we are in -- graphics or text --> aka formatted or unformatted
 #endif
 
 #if defined(DEBUG)
@@ -1576,6 +1577,7 @@
 	int x,y; /* Dimensions */
 	int skip; /* Byte distance between vertically consecutive pixels */
 	void *data; /* Pointer to room for topleft pixel */
+	void *user; /* For implementing LRU algor by higher layer or what*/
 	void *flags; /* Allocation flags for the driver */
 };
 
--- links-2.12.unmodified/session.c
+++ links-2.12/session.c
@@ -2244,9 +2247,12 @@
 	query_file(ses, ses->tq->url, ses->tq->ce ? ses->tq->ce->head : NULL, &continue_download, tp_cancel, DOWNLOAD_CONTINUE);
 }
 
+int g_xwin =0;
 static void tp_open(struct session *ses)
 {
 	continue_download(ses, cast_uchar "", DOWNLOAD_DEFAULT);
+	if(g_xwin)
+		SDL_WM_IconifyWindow();	
 }
 
 static int ses_abort_1st_state_loading(struct session *ses)
@@ -2319,6 +2325,7 @@
 
 	if (!a) internal("This should not happen.\n");
 	ses->tq_prog = stracpy(a->prog), ses->tq_prog_flag_block = a->block, ses->tq_prog_flag_direct = direct_download_possible(ses->tq, a);
+	g_xwin = a->xwin;	
 	tp_open(ses);
 	cancel_dialog(dlg,idata);
 	return 0;
@@ -2396,6 +2403,7 @@
 
 	if (a) ses->tq_prog = stracpy(a[0].prog), ses->tq_prog_flag_block = a[0].block, ses->tq_prog_flag_direct = direct_download_possible(ses->tq, a);
 	if (a && !a[0].ask) {
+	g_xwin = a->xwin;
 		tp_open(ses);
 		if (n) mem_free(a);
 		mem_free(ct);
@@ -2406,6 +2414,7 @@
 		if (!anonymous) msg_box(ses->term, getml(m1, NULL), TEXT_(T_UNKNOWN_TYPE), AL_CENTER | AL_EXTD_TEXT, TEXT_(T_CONTENT_TYPE_IS), cast_uchar " ", m1, cast_uchar ".\n", TEXT_(T_DO_YOU_WANT_TO_SAVE_OR_DISLPAY_THIS_FILE), NULL, ses, 3, TEXT_(T_SAVE), tp_save, B_ENTER, TEXT_(T_DISPLAY), tp_display, 0, TEXT_(T_CANCEL), tp_cancel, B_ESC);
 		else msg_box(ses->term, getml(m1, NULL), TEXT_(T_UNKNOWN_TYPE), AL_CENTER | AL_EXTD_TEXT, TEXT_(T_CONTENT_TYPE_IS), cast_uchar " ", m1, cast_uchar ".\n", TEXT_(T_DO_YOU_WANT_TO_SAVE_OR_DISLPAY_THIS_FILE), NULL, ses, 2, TEXT_(T_DISPLAY), tp_display, B_ENTER, TEXT_(T_CANCEL), tp_cancel, B_ESC);
 	} else {
+		g_xwin = a->xwin;
 		m2 = stracpy(a[0].label ? a[0].label : (unsigned char *)"");
 		if (!anonymous) msg_box(ses->term, getml(m1, m2, NULL), TEXT_(T_WHAT_TO_DO), AL_CENTER | AL_EXTD_TEXT, TEXT_(T_CONTENT_TYPE_IS), cast_uchar " ", m1, cast_uchar ".\n", TEXT_(T_DO_YOU_WANT_TO_OPEN_FILE_WITH), cast_uchar " ", m2, cast_uchar ", ", TEXT_(T_SAVE_IT_OR_DISPLAY_IT), NULL, ses, 4, TEXT_(T_OPEN), tp_open, B_ENTER, TEXT_(T_SAVE), tp_save, 0, TEXT_(T_DISPLAY), tp_display, 0, TEXT_(T_CANCEL), tp_cancel, B_ESC);
 		else msg_box(ses->term, getml(m1, m2, NULL), TEXT_(T_WHAT_TO_DO), AL_CENTER | AL_EXTD_TEXT, TEXT_(T_CONTENT_TYPE_IS), cast_uchar " ", m1, cast_uchar ".\n", TEXT_(T_DO_YOU_WANT_TO_OPEN_FILE_WITH), cast_uchar " ", m2, cast_uchar ", ", TEXT_(T_SAVE_IT_OR_DISPLAY_IT), NULL, ses, 3, TEXT_(T_OPEN), tp_open, B_ENTER, TEXT_(T_DISPLAY), tp_display, 0, TEXT_(T_CANCEL), tp_cancel, B_ESC);


